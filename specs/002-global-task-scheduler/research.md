# 研究与架构决策

## 决策 1: 浏览器端计时策略
- **决策**: 使用 Web Workers 运行计时循环。
- **理由**: 现代浏览器会对后台标签页的 `setInterval` 和 `setTimeout` 进行严重的节流（通常限制在 1 秒甚至更久）。为了保证定时任务的准确性（例如每秒执行的任务），必须将计时逻辑移至独立于主线程的 Web Worker 中，因为 Worker 线程在后台时受到的限制较少。
- **替代方案**: 
    - *主线程 `setInterval`*: 简单但受节流影响，不可靠。
    - *`requestAnimationFrame`*: 仅在页面可见时运行，完全不适合后台任务。
    - *追赶机制 (Catch-up)*: 在用户返回页面时执行错过的任务。虽然有用，但不能替代准时执行的需求。

## 决策 2: 构建工具链
- **决策**: 使用 Vite (Library Mode) + TypeScript。
- **理由**: Vite 提供了极快的开发服务器和基于 Rollup 的高效生产构建。其 Library Mode 原生支持输出 ESM、CJS 和 UMD 格式，非常适合构建 npm 包。TypeScript 提供类型安全，是现代库开发的标准。
- **替代方案**: 
    - *Webpack*: 配置复杂，构建速度较慢。
    - *Rollup (直接使用)*: Vite 底层就是 Rollup，直接配置 Rollup 需要更多样板代码。
    - *tsup*: 基于 esbuild，速度极快，也是不错的选择，但 Vite 生态更丰富（如 Vitest 集成）。

## 决策 3: 任务持久化
- **决策**: 仅支持内存存储 (In-Memory)，不内置持久化。
- **理由**: 作为轻量级调度库，核心职责是“调度”而非“存储”。持久化需求差异巨大（LocalStorage, IndexedDB, 文件, 数据库等），内置支持会显著增加包体积和复杂性。
- **替代方案**: 
    - *内置 LocalStorage*: 仅限浏览器，Node.js 不可用。
    - *插件式存储*: 增加了 API 复杂性，MVP 阶段暂不考虑。

## 决策 4: 调试面板实现
- **决策**: 框架无关的自定义 Web Component 或原生 DOM 操作。
- **理由**: 为了满足“不限制任何 UI 框架”的需求，调试面板不能依赖 Vue/React 等特定框架。使用原生 DOM 或 Web Components 可以确保在任何环境中都能运行，且不仅限于特定框架。
- **替代方案**: 
    - *为每个框架编写适配器*: 维护成本高。
    - *外部独立应用*: 使用不便，无法直接操作当前页面的实例。

## 决策 5: 唯一 ID 生成
- **决策**: 强制用户提供 ID 或使用简单的计数器/UUID。
- **理由**: 为了避免 ID 冲突，规范中已明确“如果 ID 已存在则抛出错误”。这要求库内部维护一个 ID 注册表。

## 决策 6: 错误重试策略
- **决策**: 指数退避 (Exponential Backoff)。
- **理由**: 这是处理瞬态故障（如网络请求失败）的标准且最健壮的策略，能有效防止系统过载。
